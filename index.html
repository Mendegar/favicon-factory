<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Favicon Factory</title>
  <link rel="icon" type="image/png" sizes="32x32" href="assets/icon-32x32.png">
  <link rel="icon" type="image/svg+xml" href="assets/icon-48x48.svg">
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;--glass:rgba(255,255,255,0.03)}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, Arial, sans-serif;background:linear-gradient(180deg,#031021 0%, #081223 60%);color:#e6eef6}
    .wrap{max-width:980px;margin:36px auto;padding:24px}
    header{display:flex;align-items:center;gap:16px}
    h1{margin:0;font-size:20px}
    .grid{display:grid;grid-template-columns:340px 1fr;gap:20px;margin-top:18px}
    .card{background:var(--card);padding:16px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    .drop{border:2px dashed rgba(255,255,255,0.06);border-radius:8px;padding:16px;text-align:center;cursor:pointer;transition:all 0.2s ease;min-height:80px;display:flex;align-items:center;justify-content:center}
    .drop:hover{border-color:rgba(255,255,255,0.1);background-color:rgba(6,182,212,0.02)}
    .drop.drag-over{border-color:rgba(6,182,212,0.5);background-color:rgba(6,182,212,0.08);transform:scale(1.02)}
    .small{font-size:13px;color:var(--muted)}
    img.preview{max-width:100%;display:block;margin:12px auto;border-radius:8px}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    button{background:linear-gradient(180deg,var(--accent),#0aa3b2);border:0;padding:10px 12px;border-radius:8px;color:#042026;font-weight:600;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);font-weight:500}
    label.range{display:flex;flex-direction:column;font-size:13px;color:var(--muted)}
    .sizes{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .filelist{display:flex;flex-direction:column;gap:8px;margin-top:10px}
    .filecard{background:var(--glass);padding:12px;border-radius:8px;display:grid;grid-template-columns:48px 1fr auto auto auto;gap:12px;align-items:center;border:1px solid rgba(255,255,255,0.03)}
    .filecard:hover{background:rgba(255,255,255,0.05)}
    .filecard img{width:48px;height:48px;object-fit:contain;border-radius:6px;background:white;padding:2px}
    .filecard .info{display:flex;flex-direction:column;gap:2px}
    .filecard .name{font-weight:600;font-size:14px}
    .filecard .size{color:var(--muted);font-size:12px}
    .filecard .code{font-family:monospace;font-size:11px;color:var(--accent);background:rgba(6,182,212,0.1);padding:4px 6px;border-radius:4px;cursor:pointer}
    .filecard .code:hover{background:rgba(6,182,212,0.2)}
    .filecard button{padding:6px 10px;font-size:12px;min-width:auto}
    textarea.snippet{width:100%;height:140px;margin-top:12px;background:transparent;border:1px dashed rgba(255,255,255,0.04);padding:12px;color:#dff6fb;border-radius:8px}
    .toggles{display:flex;gap:8px;align-items:center;margin-top:8px}
    .preview-mock{display:flex;gap:12px;align-items:center;margin-top:12px}
    .mock-tab{background:var(--glass);padding:6px 10px;border-radius:8px;display:flex;align-items:center;gap:8px}
    .muted{color:var(--muted)}
    footer{margin-top:18px;color:var(--muted);font-size:13px}
    .info{font-size:13px;color:var(--muted);margin-top:10px}
    .linklike{color:var(--accent);cursor:pointer;text-decoration:underline}
    
    /* Toast notifications */
    .toast-container{position:fixed;top:20px;right:20px;z-index:9999;display:flex;flex-direction:column;gap:8px;pointer-events:none}
    .toast{background:var(--card);border:1px solid rgba(6,182,212,0.3);border-radius:8px;padding:12px 16px;color:#e6eef6;font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,0.3);transform:translateX(100%);opacity:0;transition:all 0.3s ease;pointer-events:auto;max-width:300px}
    .toast.show{transform:translateX(0);opacity:1}
    .toast.success{border-color:rgba(34,197,94,0.5);background:linear-gradient(135deg,var(--card) 0%,rgba(34,197,94,0.1) 100%)}
    .toast.error{border-color:rgba(239,68,68,0.5);background:linear-gradient(135deg,var(--card) 0%,rgba(239,68,68,0.1) 100%)}
    .toast.warning{border-color:rgba(245,158,11,0.5);background:linear-gradient(135deg,var(--card) 0%,rgba(245,158,11,0.1) 100%)}
    .toast-close{float:right;margin-left:12px;cursor:pointer;opacity:0.7;font-weight:bold}
    .toast-close:hover{opacity:1}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 100 100">
        <rect x="0" y="0" width="100" height="100" fill="#6e8efb" rx="10"/>
        <rect x="25" y="30" width="50" height="40" fill="#ff7e5f"/>
        <rect x="35" y="50" width="10" height="20" fill="#fff"/>
        <rect x="55" y="50" width="10" height="20" fill="#fff"/>
        <polygon points="20,30 80,30 70,15 30,15" fill="#a777e3"/>
        <rect x="60" y="15" width="5" height="15" fill="#ff7e5f"/>
        <rect x="58" y="10" width="9" height="5" fill="#ff7e5f"/>
        <rect x="43" y="50" width="14" height="20" fill="#ffb85c"/>
        <circle cx="50" cy="60" r="2" fill="#fff"/>
        <rect x="30" y="35" width="8" height="8" fill="#a777e3" rx="1"/>
        <rect x="62" y="35" width="8" height="8" fill="#a777e3" rx="1"/>
        <circle cx="15" cy="25" r="5" fill="#ffb85c"/>
        <circle cx="85" cy="25" r="5" fill="#ffb85c"/>
        <circle cx="15" cy="75" r="5" fill="#ffb85c"/>
        <circle cx="85" cy="75" r="5" fill="#ffb85c"/>
        <circle cx="62.5" cy="5" r="3" fill="#fff" opacity="0.8"/>
        <circle cx="65" cy="2" r="2" fill="#fff" opacity="0.6"/>
      </svg>
      <div>
        <h1>Favicon Factory</h1>
        <div class="small">Локальная клиентская генерация фавиконок из изображения, ZIP-скачивание и готовый HTML-код.</div>
      </div>
    </header>

    <div class="grid">
      <div class="card">
        <div id="drop" class="drop">
          <div id="dropText">Перетащите изображение сюда или <span class="linklike" id="browse">выберите файл</span></div>
          <input id="file" type="file" accept="image/*" style="display:none" />
        </div>

        <div id="previewWrap" style="display:none">
          <canvas id="cropCanvas" width="512" height="512" style="width:100%;height:auto;border-radius:8px;margin-top:12px;background:white;display:block"></canvas>
          <div class="controls">
            <label class="range">Кадр (масштаб)
              <input id="zoom" type="range" min="1" max="3" step="0.01" value="1">
            </label>
            <div style="display:flex;gap:8px;align-items:center">
              <span class="small">Форма:</span>
              <select id="cropShape" style="background:var(--card);color:#e6eef6;border:1px solid rgba(255,255,255,0.1);padding:4px 8px;border-radius:4px;font-size:12px">
                <option value="square">Квадрат</option>
                <option value="circle">Круг</option>
                <option value="rounded">Скругленные углы</option>
                <option value="rounded-large">Сильно скругленные</option>
              </select>
            </div>
            <button id="reset" class="ghost">Сброс</button>
            <button id="generate">Сгенерировать фавиконки</button>
          </div>
          
          <!-- Фильтры изображения -->
          <div class="controls" style="margin-top:8px;border-top:1px solid rgba(255,255,255,0.05);padding-top:8px">
            <label class="range">Яркость
              <input id="brightness" type="range" min="0" max="200" step="1" value="100">
            </label>
            <label class="range">Контрастность
              <input id="contrast" type="range" min="0" max="200" step="1" value="100">
            </label>
            <label class="range">Насыщенность
              <input id="saturation" type="range" min="0" max="200" step="1" value="100">
            </label>
            <button id="resetFilters" class="ghost" style="font-size:11px">Сбросить фильтры</button>
          </div>
          
          <!-- Трансформации -->
          <div class="controls" style="margin-top:8px;border-top:1px solid rgba(255,255,255,0.05);padding-top:8px">
            <button id="rotateLeft" class="ghost" title="Повернуть влево на 90°">↺ 90°</button>
            <button id="rotateRight" class="ghost" title="Повернуть вправо на 90°">↻ 90°</button>
            <button id="flipHorizontal" class="ghost" title="Отразить по горизонтали">↔️ Гориз.</button>
            <button id="flipVertical" class="ghost" title="Отразить по вертикали">↕️ Верт.</button>
            <button id="resetTransforms" class="ghost" style="font-size:11px">Сбросить трансформации</button>
          </div>
          
          <div class="info">Совет: обрежьте важный элемент в центре — фавиконка должна быть читаема при 16×16.</div>
        </div>

        <div id="emptyInfo" class="info">Поддерживаемые форматы загрузки: PNG, JPG, SVG. SVG конвертируется в растр при загрузке.</div>
      </div>

      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div class="small">Выходные форматы</div>
            <div class="muted">Выберите размеры, которые нужно сгенерировать</div>
          </div>
          <div class="toggles">
            <label class="small"><input type="checkbox" id="includeManifest" checked> manifest.json</label>
            <label class="small"><input type="checkbox" id="includeWin"> Windows tiles</label>
          </div>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap">
          <span class="small">Пресеты:</span>
          <select id="sizePreset" style="background:var(--card);color:#e6eef6;border:1px solid rgba(255,255,255,0.1);padding:4px 8px;border-radius:4px;font-size:12px">
            <option value="default">По умолчанию</option>
            <option value="web">Веб (основные)</option>
            <option value="pwa">PWA приложения</option>
            <option value="apple">Apple экосистема</option>
            <option value="android">Android</option>
            <option value="windows">Windows плитки</option>
            <option value="watch">Apple Watch</option>
            <option value="all">Все размеры</option>
          </select>
          <button id="selectAll" class="ghost" style="padding:4px 8px;font-size:12px">Выбрать все</button>
          <button id="deselectAll" class="ghost" style="padding:4px 8px;font-size:12px">Снять все</button>
        </div>
        
        <div class="sizes" id="sizesCheckboxes">
          <!-- generated by script -->
        </div>

        <div class="filelist" id="files"></div>

        <div style="margin-top:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <button id="downloadZip" class="ghost">📦 Скачать все .zip</button>
          <button id="copyHtml">Скопировать HTML-код</button>
          <button id="clearAll" class="ghost" style="margin-left:auto">🗑️ Очистить всё</button>
        </div>

        <textarea id="htmlSnippet" class="snippet" readonly placeholder="HTML-код появится здесь после генерации..."></textarea>

        <div class="preview-mock">
          <div class="mock-tab"><img id="tabIcon" src="" width="16" height="16"><span class="small muted">Вкладка</span></div>
          <div class="mock-tab"><img id="homeIcon" src="" width="72" height="72" style="border-radius:12px"><span class="small muted">Иконка на мобильном</span></div>
        </div>

      </div>
    </div>

    <footer>Надо было что-то дропнуть на гитхаб, дропнул это</footer>
  </div>

  <!-- Toast notifications container -->
  <div id="toast-container" class="toast-container"></div>

  <!-- External libs (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://unpkg.com/icojs@2.0.0/dist/ico.min.js"></script>

  <script>
    // --- Toast notifications ---
    const toastContainer = document.getElementById('toast-container');
    
    function showToast(message, type = 'info', duration = 4000) {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      
      const closeBtn = document.createElement('span');
      closeBtn.className = 'toast-close';
      closeBtn.innerHTML = '×';
      closeBtn.onclick = () => hideToast(toast);
      
      toast.innerHTML = message;
      toast.appendChild(closeBtn);
      
      toastContainer.appendChild(toast);
      
      // Показываем toast с анимацией
      setTimeout(() => toast.classList.add('show'), 100);
      
      // Автоматически скрываем через duration
      setTimeout(() => hideToast(toast), duration);
      
      return toast;
    }
    
    function hideToast(toast) {
      toast.classList.remove('show');
      setTimeout(() => {
        if (toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, 300);
    }
    
    // Короткие функции для разных типов
    function showSuccess(message, duration = 3000) {
      return showToast(message, 'success', duration);
    }
    
    function showError(message, duration = 5000) {
      return showToast(message, 'error', duration);
    }
    
    function showWarning(message, duration = 4000) {
      return showToast(message, 'warning', duration);
    }
    
    function showInfo(message, duration = 4000) {
      return showToast(message, 'info', duration);
    }
    
    function showConfirm(message, onConfirm, onCancel = null) {
      const toast = document.createElement('div');
      toast.className = 'toast warning';
      
      const messageDiv = document.createElement('div');
      messageDiv.textContent = message;
      messageDiv.style.marginBottom = '8px';
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '8px';
      buttonContainer.style.marginTop = '8px';
      
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = 'Да';
      confirmBtn.style.cssText = 'background:#22c55e;color:white;border:none;padding:4px 12px;border-radius:4px;cursor:pointer;font-size:12px';
      confirmBtn.onclick = () => {
        hideToast(toast);
        if (onConfirm) onConfirm();
      };
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Отмена';
      cancelBtn.style.cssText = 'background:transparent;color:#94a3b8;border:1px solid #94a3b8;padding:4px 12px;border-radius:4px;cursor:pointer;font-size:12px';
      cancelBtn.onclick = () => {
        hideToast(toast);
        if (onCancel) onCancel();
      };
      
      buttonContainer.appendChild(confirmBtn);
      buttonContainer.appendChild(cancelBtn);
      
      toast.appendChild(messageDiv);
      toast.appendChild(buttonContainer);
      
      toastContainer.appendChild(toast);
      
      // Показываем toast с анимацией
      setTimeout(() => toast.classList.add('show'), 100);
      
      return toast;
    }

    // --- UI bootstrap ---
    const drop = document.getElementById('drop');
    const fileInput = document.getElementById('file');
    const browse = document.getElementById('browse');
    const previewWrap = document.getElementById('previewWrap');
    const emptyInfo = document.getElementById('emptyInfo');
    const cropCanvas = document.getElementById('cropCanvas');
    const ctx = cropCanvas.getContext('2d');
    const zoomInput = document.getElementById('zoom');
    const cropShapeSelect = document.getElementById('cropShape');
    const resetBtn = document.getElementById('reset');
    const generateBtn = document.getElementById('generate');
    const brightnessInput = document.getElementById('brightness');
    const contrastInput = document.getElementById('contrast');
    const saturationInput = document.getElementById('saturation');
    const resetFiltersBtn = document.getElementById('resetFilters');
    const rotateLeftBtn = document.getElementById('rotateLeft');
    const rotateRightBtn = document.getElementById('rotateRight');
    const flipHorizontalBtn = document.getElementById('flipHorizontal');
    const flipVerticalBtn = document.getElementById('flipVertical');
    const resetTransformsBtn = document.getElementById('resetTransforms');
    const sizesContainer = document.getElementById('sizesCheckboxes');
    const filesList = document.getElementById('files');
    const downloadZipBtn = document.getElementById('downloadZip');
    const sizePreset = document.getElementById('sizePreset');
    const selectAllBtn = document.getElementById('selectAll');
    const deselectAllBtn = document.getElementById('deselectAll');
    const htmlSnippet = document.getElementById('htmlSnippet');
    const copyHtmlBtn = document.getElementById('copyHtml');
    const clearAllBtn = document.getElementById('clearAll');
    const includeManifest = document.getElementById('includeManifest');
    const includeWin = document.getElementById('includeWin');
    const tabIcon = document.getElementById('tabIcon');
    const homeIcon = document.getElementById('homeIcon');

    const DEFAULT_SIZES = [16,24,32,48,64,72,96,128,144,152,180,192,256,384,512];
    
    // Расширенные размеры для разных платформ
    const PLATFORM_SIZES = {
      'web': [16,32,48,96,192],
      'pwa': [72,96,128,144,152,192,384,512],
      'apple': [57,60,72,76,114,120,144,152,167,180],
      'android': [36,48,72,96,144,192,256,384,512],
      'windows': [70,150,310],
      'watch': [24,27.5,29,40,44,46,50,86,98,108,117,129,172,196,234],
      'all': [16,24,29,32,40,48,57,60,64,70,72,76,86,96,114,120,128,144,150,152,167,172,180,192,196,234,256,310,384,512]
    };

    // render size checkboxes
    function renderSizeCheckboxes(sizes = DEFAULT_SIZES) {
      sizesContainer.innerHTML = '';
      sizes.forEach(s=>{
        const id = 'size_'+s;
        const el = document.createElement('label');
        el.className = 'small';
        const isChecked = s <= 192 || [180, 384, 512].includes(s);
        el.innerHTML = `<input type="checkbox" data-size="${s}" id="${id}" ${isChecked ? 'checked': ''}> ${s}×${s}`;
        sizesContainer.appendChild(el);
      });
    }
    
    // Initial render
    renderSizeCheckboxes();
    
    // Preset handlers
    sizePreset.addEventListener('change', (e) => {
      const preset = e.target.value;
      if (preset === 'default') {
        renderSizeCheckboxes(DEFAULT_SIZES);
      } else if (PLATFORM_SIZES[preset]) {
        renderSizeCheckboxes(PLATFORM_SIZES[preset]);
      }
    });
    
    selectAllBtn.addEventListener('click', () => {
      const checkboxes = sizesContainer.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(cb => cb.checked = true);
    });
    
    deselectAllBtn.addEventListener('click', () => {
      const checkboxes = sizesContainer.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach(cb => cb.checked = false);
    });

    // Предотвращаем стандартное поведение drag & drop для всего документа
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      document.addEventListener(eventName, e => e.preventDefault(), false);
    });
    
    // drag & drop
    let dragCounter = 0; // Счетчик для отслеживания вложенных drag событий
    
    drop.addEventListener('dragenter',e=>{
      e.preventDefault();
      dragCounter++;
      drop.classList.add('drag-over');
      console.log('dragenter', dragCounter);
    });
    
    drop.addEventListener('dragover',e=>{
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
    });
    
    drop.addEventListener('dragleave',e=>{
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) {
        drop.classList.remove('drag-over');
      }
    });
    
    drop.addEventListener('drop',e=>{
      e.preventDefault();
      dragCounter = 0;
      drop.classList.remove('drag-over');
      console.log('drop event triggered');
      
      const files = e.dataTransfer.files;
      console.log('files:', files.length);
      if(files.length > 0) {
        const file = files[0];
        console.log('file type:', file.type, 'name:', file.name);
        // Проверяем тип файла
        if(file.type.startsWith('image/')) {
          handleFile(file);
        } else {
          showWarning('Пожалуйста, выберите файл изображения (PNG, JPG, GIF, SVG)');
        }
      }
    });
    browse.addEventListener('click',()=>fileInput.click());
    fileInput.addEventListener('change',e=>{const f=e.target.files[0];if(f)handleFile(f)})

    let originalImage = null; // Image object
    let imgURL = null;
    let zoom = 1;
    let originalSVG = null; // SVG element for vector operations
    let isSVGFile = false; // Track if current file is SVG
    let filters = {
      brightness: 100,
      contrast: 100,
      saturation: 100
    };
    let transforms = {
      rotation: 0, // В градусах (0, 90, 180, 270)
      flipX: false,
      flipY: false
    };
    let cropShape = 'square'; // square, circle, rounded, rounded-large

    async function handleFile(file){
      console.log('handleFile called with:', file.name, file.type, file.size);
      resetState();
      
      if(file.type === 'image/svg+xml') {
        // Векторная обработка SVG
        await handleSVGFile(file);
      } else {
        // Обычная обработка растровых изображений
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = ()=>{
          console.log('Image loaded successfully:', img.width, 'x', img.height);
          originalImage = img;
          imgURL = url;
          previewWrap.style.display='block';
          emptyInfo.style.display='none';
          drawCrop();
        }
        img.onerror = ()=>{
          console.error('Failed to load image');
          showError('Не удалось загрузить изображение');
        }
        img.src = url;
      }
    }
    


    async function handleSVGFile(file) {
      try {
        const svgText = await file.text();
        console.log('SVG file loaded, processing vectorially');
        
        // Создаем SVG элемент из текста
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
        const svgElement = svgDoc.querySelector('svg');
        
        if(!svgElement) {
          throw new Error('Invalid SVG file');
        }
        
        // Сохраняем оригинальный SVG для векторных операций
        originalSVG = svgElement.cloneNode(true);
        isSVGFile = true;
        
        // Устанавливаем размеры если их нет
        if(!svgElement.hasAttribute('width') || !svgElement.hasAttribute('height')) {
          const viewBox = svgElement.getAttribute('viewBox');
          if(viewBox) {
            const [x, y, w, h] = viewBox.split(' ').map(Number);
            svgElement.setAttribute('width', w);
            svgElement.setAttribute('height', h);
          } else {
            svgElement.setAttribute('width', '512');
            svgElement.setAttribute('height', '512');
          }
        }
        
        // Конвертируем SVG в высококачественный растр (с применением текущих настроек)
        const modifiedSvgString = generateSVGIcon(512) || new XMLSerializer().serializeToString(svgElement);
        const svgBlob = new Blob([modifiedSvgString], {type: 'image/svg+xml'});
        const url = URL.createObjectURL(svgBlob);
        
        const img = new Image();
        img.onload = ()=>{
          console.log('SVG converted to raster:', img.width, 'x', img.height);
          originalImage = img;
          imgURL = url;
          previewWrap.style.display='block';
          emptyInfo.style.display='none';
          drawCrop();
        }
        img.onerror = ()=>{
          console.error('Failed to convert SVG');
          showError('Не удалось обработать SVG файл');
        }
        img.src = url;
        
      } catch(error) {
        console.error('SVG processing error:', error);
        showError('Ошибка при обработке SVG файла');
      }
    }

    function resetState(){
      previewWrap.style.display='none';
      filesList.innerHTML='';
      htmlSnippet.value='';
      tabIcon.src=''; homeIcon.src='';
      zoomInput.value = 1; zoom = 1;
      if(imgURL){URL.revokeObjectURL(imgURL);imgURL=null}
      originalSVG = null;
      isSVGFile = false;
    }

    function drawCrop(){
      if(!originalImage) return;
      const dest = cropCanvas;
      const dsize = dest.width; // square
      ctx.clearRect(0,0,dsize,dsize);
      
      // Сохраняем состояние контекста
      ctx.save();
      
      // Применяем фильтры
      const filterString = `brightness(${filters.brightness}%) contrast(${filters.contrast}%) saturate(${filters.saturation}%)`;
      ctx.filter = filterString;
      
      // Применяем трансформации
      ctx.translate(dsize/2, dsize/2); // Переносим центр координат в центр canvas
      
      if (transforms.rotation !== 0) {
        ctx.rotate(transforms.rotation * Math.PI / 180);
      }
      
      const scaleX = transforms.flipX ? -1 : 1;
      const scaleY = transforms.flipY ? -1 : 1;
      if (scaleX !== 1 || scaleY !== 1) {
        ctx.scale(scaleX, scaleY);
      }
      
      // compute crop so that center of source maps to center of canvas, with zoom
      const sxCenter = originalImage.width/2;
      const syCenter = originalImage.height/2;
      const srcW = originalImage.width / zoom;
      const srcH = originalImage.height / zoom;
      const sx = Math.max(0, sxCenter - srcW/2);
      const sy = Math.max(0, syCenter - srcH/2);
      
      // draw with smoothing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      // Рисуем относительно нового центра координат
      ctx.drawImage(originalImage, sx, sy, srcW, srcH, -dsize/2, -dsize/2, dsize, dsize);
      
      // Восстанавливаем состояние контекста
      ctx.restore();
      
      // update previews
      updatePreviews();
    }

    zoomInput.addEventListener('input',e=>{
      zoom = parseFloat(e.target.value);
      drawCrop();
    });
    
    cropShapeSelect.addEventListener('change',e=>{
      cropShape = e.target.value;
      drawCrop();
    });
    
    resetBtn.addEventListener('click',()=>{
      zoom = 1;
      zoomInput.value=1;
      drawCrop();
    });
    
    // Filter event listeners
    brightnessInput.addEventListener('input',e=>{
      filters.brightness = parseFloat(e.target.value);
      drawCrop();
    });
    
    contrastInput.addEventListener('input',e=>{
      filters.contrast = parseFloat(e.target.value);
      drawCrop();
    });
    
    saturationInput.addEventListener('input',e=>{
      filters.saturation = parseFloat(e.target.value);
      drawCrop();
    });
    
    resetFiltersBtn.addEventListener('click',()=>{
      filters = {brightness: 100, contrast: 100, saturation: 100};
      brightnessInput.value = 100;
      contrastInput.value = 100;
      saturationInput.value = 100;
      drawCrop();
    });
    
    // Transform event listeners
    rotateLeftBtn.addEventListener('click',()=>{
      transforms.rotation = (transforms.rotation - 90 + 360) % 360;
      drawCrop();
    });
    
    rotateRightBtn.addEventListener('click',()=>{
      transforms.rotation = (transforms.rotation + 90) % 360;
      drawCrop();
    });
    
    flipHorizontalBtn.addEventListener('click',()=>{
      transforms.flipX = !transforms.flipX;
      drawCrop();
    });
    
    flipVerticalBtn.addEventListener('click',()=>{
      transforms.flipY = !transforms.flipY;
      drawCrop();
    });
    
    resetTransformsBtn.addEventListener('click',()=>{
      transforms = {rotation: 0, flipX: false, flipY: false};
      drawCrop();
    });
    

    function drawRoundedRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();
    }

    function applyShapeMask(canvas, shape) {
      const size = canvas.width;
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = maskCanvas.height = size;
      const maskCtx = maskCanvas.getContext('2d');
      
      // Создаем маску формы
      maskCtx.fillStyle = 'black';
      if (shape === 'circle') {
        maskCtx.beginPath();
        maskCtx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
        maskCtx.fill();
      } else if (shape === 'rounded') {
        const radius = size * 0.1; // 10% радиус
        drawRoundedRect(maskCtx, 0, 0, size, size, radius);
      } else if (shape === 'rounded-large') {
        const radius = size * 0.2; // 20% радиус
        drawRoundedRect(maskCtx, 0, 0, size, size, radius);
      } else {
        // square - полная маска
        maskCtx.fillRect(0, 0, size, size);
      }
      
      // Применяем маску к изображению
      const resultCanvas = document.createElement('canvas');
      resultCanvas.width = resultCanvas.height = size;
      const resultCtx = resultCanvas.getContext('2d');
      
      // Рисуем изображение
      resultCtx.drawImage(canvas, 0, 0);
      
      // Применяем маску через globalCompositeOperation
      resultCtx.globalCompositeOperation = 'destination-in';
      resultCtx.drawImage(maskCanvas, 0, 0);
      
      return resultCanvas;
    }


    function generateSVGSprite(sizes) {
      if (!originalSVG) return null;
      
      // Создаем SVG спрайт
      const sprite = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      sprite.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      sprite.setAttribute('style', 'display: none;');
      
      // Добавляем defs элемент для символов
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      sprite.appendChild(defs);
      
      sizes.forEach(size => {
        // Клонируем оригинальный SVG
        const svgClone = originalSVG.cloneNode(true);
        
        // Создаем symbol элемент
        const symbol = document.createElementNS('http://www.w3.org/2000/svg', 'symbol');
        symbol.setAttribute('id', `icon-${size}`);
        symbol.setAttribute('viewBox', svgClone.getAttribute('viewBox') || `0 0 ${size} ${size}`);
        
        // Сохраняем оригинальные цвета без изменений
        
        // Копируем содержимое SVG в symbol
        while (svgClone.firstChild) {
          symbol.appendChild(svgClone.firstChild);
        }
        
        defs.appendChild(symbol);
      });
      
      // Сериализуем спрайт
      const serializer = new XMLSerializer();
      let spriteString = serializer.serializeToString(sprite);
      
      // Добавляем комментарии с инструкциями по использованию
      const instructions = `<!--
SVG Sprite Usage Instructions:

1. Include this sprite in your HTML:
   <div style="display: none;">${spriteString}</div>

2. Use icons like this:
   <svg width="16" height="16">
     <use href="#icon-16"></use>
   </svg>
   
   <svg width="32" height="32">
     <use href="#icon-32"></use>
   </svg>

Available icons: ${sizes.map(s => `#icon-${s}`).join(', ')}
-->

`;
      
      return instructions + spriteString;
    }

    function generateSVGIcon(size) {
      if (!originalSVG) return null;
      
      // Клонируем оригинальный SVG
      const svgClone = originalSVG.cloneNode(true);
      
      // Устанавливаем новые размеры
      svgClone.setAttribute('width', size);
      svgClone.setAttribute('height', size);
      
      // Применяем трансформации
      if (transforms.rotation !== 0 || transforms.flipX || transforms.flipY) {
        const transformString = [];
        
        // Центрируем трансформации
        const centerX = size / 2;
        const centerY = size / 2;
        
        if (transforms.rotation !== 0) {
          transformString.push(`rotate(${transforms.rotation} ${centerX} ${centerY})`);
        }
        
        let scaleX = transforms.flipX ? -1 : 1;
        let scaleY = transforms.flipY ? -1 : 1;
        if (scaleX !== 1 || scaleY !== 1) {
          transformString.push(`scale(${scaleX} ${scaleY})`);
          if (scaleX !== 1 || scaleY !== 1) {
            transformString.push(`translate(${scaleX !== 1 ? -size : 0} ${scaleY !== 1 ? -size : 0})`);
          }
        }
        
        if (transformString.length > 0) {
          // Оборачиваем содержимое SVG в группу с трансформациями
          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          g.setAttribute('transform', transformString.join(' '));
          
          // Перемещаем все дочерние элементы в группу
          while (svgClone.firstChild) {
            g.appendChild(svgClone.firstChild);
          }
          svgClone.appendChild(g);
        }
      }
      
      // Не применяем никаких цветовых изменений - сохраняем оригинальные цвета
      
      // Применяем фильтры если они есть (только для SVG)
      if (filters.brightness !== 100 || filters.contrast !== 100 || filters.saturation !== 100) {
        const filterId = `filter-${size}`;
        const defsElement = svgClone.querySelector('defs') || document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        if (!svgClone.querySelector('defs')) {
          svgClone.insertBefore(defsElement, svgClone.firstChild);
        }
        
        const filterElement = document.createElementNS('http://www.w3.org/2000/svg', 'filter');
        filterElement.setAttribute('id', filterId);
        
        // Компонент яркости
        if (filters.brightness !== 100) {
          const feComponentTransfer = document.createElementNS('http://www.w3.org/2000/svg', 'feComponentTransfer');
          const feFuncR = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncR');
          const feFuncG = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncG');
          const feFuncB = document.createElementNS('http://www.w3.org/2000/svg', 'feFuncB');
          
          const slope = filters.brightness / 100;
          feFuncR.setAttribute('type', 'linear');
          feFuncR.setAttribute('slope', slope);
          feFuncG.setAttribute('type', 'linear');
          feFuncG.setAttribute('slope', slope);
          feFuncB.setAttribute('type', 'linear');
          feFuncB.setAttribute('slope', slope);
          
          feComponentTransfer.appendChild(feFuncR);
          feComponentTransfer.appendChild(feFuncG);
          feComponentTransfer.appendChild(feFuncB);
          filterElement.appendChild(feComponentTransfer);
        }
        
        // Насыщенность
        if (filters.saturation !== 100) {
          const feColorMatrix = document.createElementNS('http://www.w3.org/2000/svg', 'feColorMatrix');
          const satValue = filters.saturation / 100;
          feColorMatrix.setAttribute('type', 'saturate');
          feColorMatrix.setAttribute('values', satValue.toString());
          filterElement.appendChild(feColorMatrix);
        }
        
        defsElement.appendChild(filterElement);
        
        // Применяем фильтр ко всем элементам
        const allElements = svgClone.querySelectorAll('*');
        allElements.forEach(el => {
          if (el.tagName !== 'defs' && el.tagName !== 'filter') {
            el.setAttribute('filter', `url(#${filterId})`);
          }
        });
      }
      
      // Сериализуем SVG в строку
      const serializer = new XMLSerializer();
      const svgString = serializer.serializeToString(svgClone);
      
      return svgString;
    }

    function optimizeForSmallSize(canvas, size) {
      // Оптимизация для размеров меньше 32px
      if (size >= 32) return canvas;
      
      const optimized = document.createElement('canvas');
      optimized.width = optimized.height = size;
      const ctx = optimized.getContext('2d');
      
      // Отключаем сглаживание для очень мелких размеров для четкости
      ctx.imageSmoothingEnabled = size > 16;
      if (ctx.imageSmoothingEnabled) {
        ctx.imageSmoothingQuality = 'high';
      }
      
      // Увеличиваем контрастность для мелких размеров
      const contrastBoost = size <= 16 ? 1.2 : 1.1;
      const brightnessBoost = size <= 16 ? 1.05 : 1.02;
      
      ctx.filter = `contrast(${contrastBoost}) brightness(${brightnessBoost})`;
      ctx.drawImage(canvas, 0, 0, size, size);
      ctx.filter = 'none';
      
      // Дополнительная четкость для 16px и меньше
      if (size <= 16) {
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        
        // Простой алгоритм увеличения четкости
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const alpha = data[i + 3];
          
          if (alpha > 128) { // Только для непрозрачных пикселей
            // Увеличиваем контрастность каждого канала
            data[i] = Math.min(255, Math.max(0, (r - 128) * 1.3 + 128));
            data[i + 1] = Math.min(255, Math.max(0, (g - 128) * 1.3 + 128));
            data[i + 2] = Math.min(255, Math.max(0, (b - 128) * 1.3 + 128));
          }
        }
        
        ctx.putImageData(imageData, 0, 0);
      }
      
      return optimized;
    }

    function canvasToBlob(canvas, size){
      // returns Promise<Blob> of PNG resized to size
      const tmp = document.createElement('canvas');
      tmp.width = tmp.height = size;
      const tctx = tmp.getContext('2d');
      
      tctx.imageSmoothingEnabled = true;
      tctx.imageSmoothingQuality = 'high';
      tctx.drawImage(canvas, 0, 0, size, size);
      
      // Применяем форму кропа
      const shapedCanvas = applyShapeMask(tmp, cropShape);
      
      // Применяем оптимизацию для мелких размеров
      const optimizedCanvas = optimizeForSmallSize(shapedCanvas, size);
      
      return new Promise(res=>optimizedCanvas.toBlob(res,'image/png'));
    }

    function blobToArrayBuffer(blob){return new Promise((r)=>{const fr=new FileReader();fr.onload=()=>r(fr.result);fr.readAsArrayBuffer(blob);})}

    function dataURLFromCanvas(canvas){return canvas.toDataURL('image/png')}

    function updatePreviews(){
      tabIcon.src = cropCanvas.toDataURL('image/png',1);
      homeIcon.src = cropCanvas.toDataURL('image/png',1);
    }

    async function generateAll(){
      if(!originalImage) return showWarning('Нужно сначала загрузить изображение');
      const checkedSizes = Array.from(sizesContainer.querySelectorAll('input[type=checkbox]:checked')).map(i=>parseInt(i.dataset.size));
      if(checkedSizes.length===0) return showWarning('Выберите хотя бы один размер');

      filesList.innerHTML='';
      const zip = new JSZip();
      const filesMeta = [];

      // generate PNG files
      for(const s of checkedSizes){
        const blob = await canvasToBlob(cropCanvas, s);
        zip.file(`icon-${s}x${s}.png`, blob);
        const url = URL.createObjectURL(blob);
        const sizeKB = Math.round(blob.size/10.24)/100;
        filesMeta.push({name:`icon-${s}x${s}.png`, sizeKB, url, blob, w:s});
      }
      
      // generate SVG files (if original was SVG)
      if (isSVGFile && originalSVG) {
        console.log('Generating vector SVG files...');
        for(const s of checkedSizes) {
          const svgString = generateSVGIcon(s);
          if (svgString) {
            const svgBlob = new Blob([svgString], {type: 'image/svg+xml'});
            zip.file(`icon-${s}x${s}.svg`, svgBlob);
            const url = URL.createObjectURL(svgBlob);
            const sizeKB = Math.round(svgBlob.size/10.24)/100;
            filesMeta.push({name:`icon-${s}x${s}.svg`, sizeKB, url, blob: svgBlob, w:s});
          }
        }
        
        // Добавляем основной SVG файл (оригинальный размер)
        const originalSvgString = new XMLSerializer().serializeToString(originalSVG);
        const originalSvgBlob = new Blob([originalSvgString], {type: 'image/svg+xml'});
        zip.file('favicon.svg', originalSvgBlob);
        const originalSvgUrl = URL.createObjectURL(originalSvgBlob);
        const originalSizeKB = Math.round(originalSvgBlob.size/10.24)/100;
        filesMeta.unshift({name:'favicon.svg', sizeKB: originalSizeKB, url: originalSvgUrl, blob: originalSvgBlob, w: null});
        
        // Создаем SVG спрайт
        const spriteString = generateSVGSprite(checkedSizes);
        if (spriteString) {
          const spriteBlob = new Blob([spriteString], {type: 'image/svg+xml'});
          zip.file('icons-sprite.svg', spriteBlob);
          const spriteUrl = URL.createObjectURL(spriteBlob);
          const spriteSizeKB = Math.round(spriteBlob.size/10.24)/100;
          filesMeta.push({name:'icons-sprite.svg', sizeKB: spriteSizeKB, url: spriteUrl, blob: spriteBlob, w: null});
        }
        
      }

      // generate favicon.ico (aggregate common small sizes)
      const icoSizes = [16,32,48].filter(s=>checkedSizes.includes(s));
      if(icoSizes.length>0){
        // create array buffers for PNGs (icojs accepts raw RGBA or PNG buffers)
        const pngBuffers = [];
        for(const s of icoSizes){
          const blob = await canvasToBlob(cropCanvas, s);
          const ab = await blobToArrayBuffer(blob);
          pngBuffers.push({buffer:ab,width:s,height:s});
        }
        // use icojs to create ICO from array buffers
        try{
          const icoArrayBuffer = icojs.write(pngBuffers, 'image/png');
          const icoBlob = new Blob([icoArrayBuffer], {type:'image/x-icon'});
          zip.file('favicon.ico', icoBlob);
          const url = URL.createObjectURL(icoBlob);
          filesMeta.unshift({name:'favicon.ico',sizeKB:Math.round(icoBlob.size/10.24)/100,url,blob:icoBlob,w:null});
        }catch(e){console.warn('icojs error',e)}
      }

      // manifest.json + browserconfig.xml
      if(includeManifest.checked){
        // build icons array with best-available sizes (prefer 192 & 512 if present, else create from largest)
        const manifestIcons = checkedSizes.map(s=>({src:`/assets/icon-${s}x${s}.png`,sizes:`${s}x${s}`,type:'image/png'}));
        const manifest = {name:'Site name',short_name:'Site',icons:manifestIcons,start_url:"/",display:'standalone',background_color:'#ffffff',theme_color:'#06b6d4'};
        const manifestBlob = new Blob([JSON.stringify(manifest,null,2)],{type:'application/json'});
        zip.file('manifest.webmanifest',manifestBlob);
        filesMeta.push({name:'manifest.webmanifest',sizeKB:Math.round(manifestBlob.size/10.24)/100,url:null,blob:manifestBlob,w:null});
      }

      if(includeWin.checked){
        const xml = `<?xml version="1.0" encoding="utf-8"?>\n<browserconfig>\n  <msapplication>\n    <tile>\n      <square70x70logo src="/assets/icon-70x70.png"/>\n      <square150x150logo src="/assets/icon-150x150.png"/>\n      <wide310x150logo src="/assets/icon-310x150.png"/>\n      <square310x310logo src="/assets/icon-310x310.png"/>\n      <TileColor>#06b6d4</TileColor>\n    </tile>\n  </msapplication>\n</browserconfig>`;
        const blob = new Blob([xml],{type:'application/xml'});
        zip.file('browserconfig.xml',blob);
        filesMeta.push({name:'browserconfig.xml',sizeKB:Math.round(blob.size/10.24)/100,url:null,blob,w:null});
      }

      // add assets folder that matches manifest paths
      const assetsFolder = zip.folder('assets');
      for(const f of filesMeta){
        if(f.name.endsWith('.png')){
          // add from blob already in zip (we added top-level icon-X files earlier) - duplicate in assets for manifest paths
          const ab = await blobToArrayBuffer(f.blob);
          assetsFolder.file(f.name, ab);
        }
      }

      // populate files list UI
      for(const m of filesMeta){
        const el = document.createElement('div'); 
        el.className='filecard';
        
        // Иконка
        const img = document.createElement('img');
        img.src = m.url || '';
        
        // Информация
        const info = document.createElement('div');
        info.className = 'info';
        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = m.name;
        const size = document.createElement('div');
        size.className = 'size';
        size.textContent = m.sizeKB ? `${m.sizeKB} KB` : '';
        info.appendChild(name);
        info.appendChild(size);
        
        // HTML код для вставки
        const code = document.createElement('div');
        code.className = 'code';
        let htmlCode = '';
        if(m.name.endsWith('.png')) {
          const sizeMatch = m.name.match(/(\d+)x\d+/);
          const iconSize = sizeMatch ? sizeMatch[1] : '32';
          htmlCode = `<link rel="icon" sizes="${iconSize}x${iconSize}" href="/assets/${m.name}">`;
        } else if(m.name.endsWith('.svg')) {
          if(m.name === 'favicon.svg') {
            htmlCode = '<link rel="icon" type="image/svg+xml" href="/favicon.svg">';
          } else {
            const sizeMatch = m.name.match(/(\d+)x\d+/);
            const iconSize = sizeMatch ? sizeMatch[1] : '32';
            htmlCode = `<link rel="icon" type="image/svg+xml" sizes="${iconSize}x${iconSize}" href="/assets/${m.name}">`;
          }
        } else if(m.name === 'favicon.ico') {
          htmlCode = '<link rel="shortcut icon" href="/favicon.ico">';
        } else if(m.name.includes('manifest')) {
          htmlCode = '<link rel="manifest" href="/manifest.webmanifest">';
        } else if(m.name.includes('browserconfig')) {
          htmlCode = '<meta name="msapplication-config" content="/browserconfig.xml">';
        } else if(m.name === 'icons-sprite.svg') {
          htmlCode = '<!-- Include sprite: <div style="display:none;">[sprite content]</div> then use: <svg><use href="#icon-16"></use></svg> -->';
        }
        code.textContent = htmlCode;
        code.title = 'Нажмите, чтобы скопировать';
        code.addEventListener('click', () => {
          navigator.clipboard.writeText(htmlCode).then(() => {
            code.style.background = 'rgba(34,197,94,0.2)';
            setTimeout(() => code.style.background = 'rgba(6,182,212,0.1)', 1000);
            showSuccess(`📋 Код для ${m.name} скопирован`);
          });
        });
        
        // Кнопка скачивания
        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'ghost';
        downloadBtn.textContent = '↓';
        downloadBtn.title = 'Скачать файл';
        downloadBtn.addEventListener('click', () => {
          const a = document.createElement('a');
          a.href = m.url;
          a.download = m.name;
          a.click();
        });
        
        el.appendChild(img);
        el.appendChild(info);
        el.appendChild(code);
        el.appendChild(downloadBtn);
        filesList.appendChild(el);
      }

      // prepare downloadable zip
      const zipBlob = await zip.generateAsync({type:'blob'});
      const zipUrl = URL.createObjectURL(zipBlob);
      downloadZipBtn.onclick = ()=>{const a=document.createElement('a');a.href=zipUrl;a.download='favicon-factory-assets.zip';a.click()}

      // prepare HTML head snippet
      buildHtmlSnippet(checkedSizes, !!includeManifest.checked, !!includeWin.checked);

      // set previews to best small icons
      const best16 = filesMeta.find(f=>f.name.includes('16x16') || f.name==='favicon.ico');
      if(best16) tabIcon.src = best16.url;
      const best192 = filesMeta.find(f=>f.name.includes('192x192') || f.name.includes('150x150') || f.name.includes('180x180'));
      if(best192) homeIcon.src = best192.url;

      showSuccess('🎉 Генерация завершена! ZIP готов к скачиванию и HTML-код сгенерирован.');
    }

    function buildHtmlSnippet(sizes, withManifest, withWin){
      const lines = [];
      lines.push('<!-- Favicon Factory — вставьте в <head> -->');
      // favicon.ico
      lines.push('<link rel="shortcut icon" href="/favicon.ico">');
      // PNG icons
      sizes.sort((a,b)=>a-b);
      for(const s of sizes){
        lines.push(`<link rel="icon" type="image/png" sizes=\"${s}x${s}\" href=\"/assets/icon-${s}x${s}.png\">`);
      }
      // apple touch
      if(sizes.includes(180) || sizes.includes(192)){
        const aSize = sizes.includes(180)?180:192;
        lines.push(`<link rel=\"apple-touch-icon\" sizes=\"${aSize}x${aSize}\" href=\"/assets/icon-${aSize}x${aSize}.png\">`);
      }
      if(withManifest) lines.push('<link rel="manifest" href="/manifest.webmanifest">');
      if(withWin) lines.push('<meta name="msapplication-config" content="/browserconfig.xml">');
      lines.push('<!-- Конец -->');
      htmlSnippet.value = lines.join('\n');
    }

    generateBtn.addEventListener('click',()=>{generateAll()});
    copyHtmlBtn.addEventListener('click',()=>{navigator.clipboard.writeText(htmlSnippet.value).then(()=>showSuccess('📋 HTML-код скопирован в буфер обмена'))});
    clearAllBtn.addEventListener('click',()=>{
      showConfirm('Очистить все данные и начать заново?', () => {
        resetState();
        emptyInfo.style.display='block';
        originalImage = null;
        showInfo('🗑️ Все данные очищены');
        console.log('All data cleared');
      });
    });

    // quick keyboard shortcuts
    document.addEventListener('keydown',e=>{if(e.ctrlKey && e.key==='g'){e.preventDefault();generateAll()}})
  </script>
</body>
</html>
